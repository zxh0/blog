# 理解比特币（一）：下载区块数据

看题目就知道，这是一个系列文章的第一篇😊。写这个系列文章的最主要目的，是想推动自己把目前对于比特币技术的一些理解整理出来。如果这些文章顺便能帮助到对比特币底层技术感兴趣的读者朋友们，那就更好了。

在这篇文章里，我们将讨论如何用最简单的办法，按高度下载比特币主网区块的原始数据（Raw Data，用16进制字符串表示）。如何将原始数据解析为更有意义的区块结构，将在下一篇文章中进行讨论。这个系列的每一篇文章都有配套的、直接可执行的Go语言代码。本文的配套代码，可以从[这里](https://github.com/zxh0/blog/tree/mybtc_a1/code/go/mybtc)获取。



## BTC节点类型

比特币归根结底就是一个分布式账本，这个账本由众多的比特币节点（Node）共同维护。每隔一段时间（大约10分钟），将有一页账本产生。一页账本通常叫做一个区块（Block），所有的区块按先后顺序够成一个哈希链表，简称区块链（Blockchain）。节点通过某种公平（但及其耗电）的竞赛来决定由谁产生下一个区块，赢得竞赛的节点，将获得一定数量（每4年减半）的比特币，以补偿其消耗的电力，并表彰其为维护账本所付出的努力。节点通过参与竞赛获得比特币奖励的过程俗称“挖矿”（Mining），这些节点俗称“矿工”（Miner）。

不过，由于比特币账本已经非常庞大了（在写这篇文章时，比特币已经产生了[692297](https://bitcoinexplorer.org/)个区块，大约占用[350G](https://www.statista.com/statistics/647523/worldwide-bitcoin-blockchain-size/)磁盘空间），所以并不是每个节点都有条件（或有必要）下载/保留完整的区块数据。根据功能，比特币节点可以分为：全节点（Full Node）、轻节点（Light Node）、挖矿节点（Mining Node）等。这里并不打算介绍太多的细节，如果读者一时半会没有理解这些概念也没关系，后面我们会展开讨论这些内容。

顾名思义，全节点肯定是功能最全的节点。如果能写代码实现一个比特币全节点，那肯定就对比特币技术了如指掌了。但是这样做工作量也太大了，要考虑的细节也太多，不太实际。这个系列将要实现的，是一个简化版的节点，会忽略非常多的细节。总之，只要能够帮助我们学习和理解比特币技术就好了。



## 获取区块的办法

我们将要实现的这个简化版节点，将下载并（尽量）验证区块。那么，第一步，自然就是下载区块数据。有了区块数据，下一步才可以解码、验证、存储区块。我想到三种下载区块数据的办法：

一，实现比特币[P2P网络协议](https://developer.bitcoin.org/reference/p2p_networking.html)，通过该协议和其他比特币全节点建立联系，然后同步区块数据。这个办法显然是最好的，因为真实的比特币全节点就是这样工作的，我们可以借此机会了解比特币P2P协议。不过，也是最难实现的，因为需要太多的准备工作了。所以我们会先选择更简单的办法，等我们对比特币有足够的了解，且积累了足够多的代码之后，再来实现P2P协议。

二，通过比特币全节点提供的[JSON-RPC服务](https://developer.bitcoin.org/reference/rpc/index.html)下载区块数据。比特币全节点提供了众多的RPC方法，其中[getblockhash](https://developer.bitcoin.org/reference/rpc/getblockhash.html)和[getblock](https://developer.bitcoin.org/reference/rpc/getblock.html)是我们需要的。前一个RPC方法可以按区块高度查询区块哈希，后一个RPC方法按区块哈希查询区块数据。这个办法不错，实现起来很容易。不过，为了保护比特币全节点的安全，很难找到对外公开RPC端口（默认是8332）的全节点。

三，通过[Blockchain.com提供的REST服务](https://www.blockchain.com/api/blockchain_api)下载区块数据。该网站提供了一个公开的区块链数据API，可以查询各种数据。其中有两个接口正是我们所需要的：[一个](https://blockchain.info/rawblock/$block_hash?format=hex)可以按高度查询区块哈希，[一个](https://blockchain.info/block-height/$block_height?format=json)可以按哈希查询区块原始数据。

办法一的工作量有点大，暂时不考虑。对于办法二，我们自己下载并运行一个比特币全节点，然后在本地提供RPC服务是可行的。不过为了简单起见，还是使用办法三吧。下面我们就来了解一下Blockchain.com提供的这两个REST接口。



## 区块链数据API

第一个接口：通过区块高度查询区块哈希。我们以创世区块（Genesis Block，高度为0）为例，调用这个接口：https://blockchain.info/block-height/0?format=json，下面是返回的数据（JSON格式，省略了大部分无关内容）：

```json
{
  "blocks": [
    {
      "hash": "000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f",
      "ver": 1,
      "prev_block":"0000000000000000000000000000000000000000000000000000000000000000",
      ...
    }
  ]
}
```

区块既可以通过区块高度标识，也可以通过区块哈希（准确的说是区块头哈希，下一篇文章会详细介绍）标识。但是，只有哈希才可以唯一标识某一个区块，高度并不可以（因为区块链有可能会临时分叉），这就是为什么返回数据中的`blocks`字段是数组的原因。不过，对于我们来说，可能很长时间之内都追不上比特币最新的区块，所以不太可能看到区块链分叉，完全可以假设`blocks`数组的长度始终为1。另外，除了哈希，这个接口其实还返回了完整的区块数据，不过我们也不需要这些数据，忽略即可。

第二个接口：通过区块哈希查询区块原始数据。我们还是以创世区块为例，调用这个接口：https://blockchain.info/rawblock/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f?format=hex，下面是返回的数据（16进制字符串，换行是为了方便展示而人为添加的）：

```
0100000000000000000000000000000000000000000000000000000000000000
000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa
4b1e5e4a29ab5f49ffff001d1dac2b7c01010000000100000000000000000000
00000000000000000000000000000000000000000000ffffffff4d04ffff001d
0104455468652054696d65732030332f4a616e2f32303039204368616e63656c
6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f75742066
6f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe554827
1967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4
f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000
```

目前来看这就是一堆杂乱的数据，在下一篇文章中，我们会讨论如何把这些数据分解，转变成有意义的区块结构。有这两个REST接口在手，我们就可以实现一个按高度查询区块原始数据的客户端了，定义如下：

```go
// mybtc/bcapi/client.go

type Client interface {
	GetRawBlockByHeight(h uint32) (string, error)
}
```

我准备了两个实现。`SimpleClient`是比较简单的实现，`GetRawBlockByHeight()`方法每次发送2个HTTP请求，先通过`block-height`接口按高度查询区块哈希，然后通过`rawblock`接口按哈希查询区块数据。由于我们会从高度1开始，按顺序下载每一个区块的数据，所以`SimpleClient`速度太慢了。`ParallelClient`在`SimpleClient`的基础之上进行了优化，会并发预先下载N个区块，所以速度要快很多。这两个实现都比较简单，这里就不贴代码了。



## 下载区块数据

在文章的最后，我们来写一个可执行程序，测试一下`bcapi.SimpleClient`。这个程序非常简单，从创始区块（高度是0）开始，依次下载每一个区块的原始数据并打印到控制台：

```go
// mybtc/cmd/mybtc/main.go

func main() {
	client := bcapi.NewSimpleClient()
	for i := uint32(0); i < 10000; i++ {
		rawBlock, err := client.GetRawBlockByHeight(i)
		if err != nil {
			fmt.Println(err.Error())
			return
		}

		fmt.Printf("block#%d: %s\n", i, rawBlock)
	}
}
```

这个可执行程序是本系列文章的起点，在后面的文章中，我们会逐渐添加更多的代码，让它越来越接近一个真正的比特币节点。在控制台执行这个程序，效果看起来是这样（区块数据做了省略处理）：

```
$ go run mybtc/cmd/mybtc
block#0: 0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd...
block#1: 010000006fe28c0ab6f1b372c1a6a246ae63f74f931e8365e15a089c68d6190000000000982051fd...
block#2: 010000004860eb18bf1b1620e37e9490fc8a427514416fd75159ab86688e9a8300000000d5fdcc54...
block#3: 01000000bddd99ccfda39da1b108ce1a5d70038d0a967bacb68b6b63065f626a0000000044f67222...
block#4: 010000004944469562ae1c2c74d9a535e00b6f3e40ffbad4f2fda3895501b582000000007a06ea98...
block#5: 0100000085144a84488ea88d221c8bd6c059da090e88f8a2c99690ee55dbba4e00000000e11c48fe...
block#6: 01000000fc33f596f822a0a1951ffdbf2a897b095636ad871707bf5d3162729b00000000379dfb96...
block#7: 010000008d778fdc15a2d3fb76b7122a3b5582bea4f21f5a0c693537e7a03130000000003f674005...
...
```



## 总结

比特币本质上是一个分布式账本，底层采用了区块链技术。比特币的账本由分布在网络上的众多比特币节点共同维护，这些节点按功能可以分为全节点、轻节点、挖矿节点等。为了鼓励节点竞争出块权，从而保证整个比特币系统的可用性和安全性，系统会奖励出块节点一定数量的比特币。比特币节点之间通过P2P协议相互联系，全节点提供了JSON-RPC服务。此外，一些区块链浏览器还提供了REST接口，可以查询区块链的各种状态。

在这篇文章里，我们讨论了如何用最简单的方式（通过Blockchain.com提供的REST接口）按高度下载区块原始数据。目前我们只是在控制台中打印出这些原始数据，在下一篇文章中，我们将讨论并定义比特币区块结构体，并写代码将原始数据解析为区块结构体。在后面的文章中，我们会把区块数据存储在本地数据库中，并逐步验证每一个区块。

